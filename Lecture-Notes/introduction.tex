\chapter{Introduction}

\section{What is Artificial Intelligence?}
Before we start to dive into the subject of
\href{https://en.wikipedia.org/wiki/Artificial_intelligence}{Artificial Intelligence} (usually abbreviated as
AI) we should ask ourselves what we mean by the phrase ``\blue{artificial intelligence}''.
According to the Oxford Dictionary of English, \index{artificial intelligence, definition}
\blue{artificial intelligence} is:
\begin{quote}
  \colorbox{sepia}{\textsl{The theory and development of computer systems able to perform tasks normally}} \linebreak
  \colorbox{sepia}{\textsl{requiring human intelligence, such as visual perception, speech recognition,}}  \linebreak
  \colorbox{sepia}{\textsl{decision-making, and translation between languages.}} 
\end{quote}
There have been two competitive approaches to machine learning.  The first approach is based on
\blue{symbolic logic} and is known as \blue{symbolic AI}.  \index{symbolic AI}
Typical tasks addressed with this approach were the development of automatic theorem provers, programs to
perform \blue{symbolic integration}, or programs to play chess like
\href{https://en.wikipedia.org/wiki/Deep_Blue_(chess_computer)}{Deep Blue}.
In the beginning, this approach was the dominant paradigm in AI.
The second approach is known as \blue{machine learning}.  Arthur Samuel defined machine learning as
``the field of study that gives computers the ability to learn without being
explicitly programmed'' \cite{samuel:1959}. \index{machine learning, definition}
Machine learning is mostly responsible for the recent hype in AI.

\section{Overview}
This lecture consists of two parts.
\begin{enumerate}
\item The first part deals with symbolic AI.
      The common theme of symbolic AI is \blue{declarative programming}.  
      The main idea of declarative programming is that we start with a \blue{formal problem specification}.
      This problem specification is a concise description of the problem that is to be solved, which is
      then fed into an \blue{automatic problem solver} that returns a solution of the problem.  Originally, 
      \href{https://en.wikipedia.org/wiki/Declarative_programming}{declarative programming} was a very general
      approach to problem-solving.  The idea was that in order to solve a problem, the problem would first be
      formulated as a logic formula and an
      \href{https://en.wikipedia.org/wiki/Automated_theorem_proving}{automated theorem prover} would then be
      able to solve the problem.  The programming language \href{https://en.wikipedia.org/wiki/Prolog}{Prolog}
      was based on that paradigm.  Unfortunately, the idea of declarative programming has
      turned out to be unsuitable as a general problem-solving framework for two reasons:
      \begin{enumerate}
      \item First, it is very difficult to specify practical problems completely in a logical framework.
      \item Second, even in those cases where it is feasible to completely specify a problem via logic formulae,
            automatic theorem proving is, in general, not powerful enough to automatically find a solution. 
      \end{enumerate}
      However, there are a number of domains where the approach of declarative programming has turned out to be
      useful.  In particular, we show how declarative programming can be used to solve problems in the
      following domains.
      \begin{enumerate}
      \item \blue{Search problems} are problems where the task is to find a path in a graph.  A typical example of a
            search problem is the \href{https://en.wikipedia.org/wiki/15_puzzle}{fifteen puzzle}.
            We discuss various state-of-the-art algorithms that can solve search problems.
      \item \href{https://en.wikipedia.org/wiki/Constraint_satisfaction_problem}{Constraint satisfaction problems} 
            have great practical importance.  Today, very efficient constraint solvers have been developed to
            solve various constraint satisfaction problems that occur in practise.

            We will first discuss various techniques for solving constraint satisfaction problems.
            Furthermore, we discuss \href{https://github.com/Z3Prover/z3}{Z3}, which is a state-of-the-art
            automatic theorem prover and constraint solver developed by
            \href{https://www.microsoft.com/en-us/research/project/z3-3/}{Microsoft}.
      \item \blue{Games} like \href{https://en.wikipedia.org/wiki/Chess}{chess} or
            \href{https://en.wikipedia.org/wiki/checkers}{checkers} can be specified declaratively and there are
            various techniques for computers to find optimal strategies for playing adversarial games.
      \end{enumerate}
      Additionally we will cover \blue{automatic theorem proving}.  As we have already discussed 
      \blue{resolution theorem proving} in our lecture on
      \href{https://github.com/karlstroetmann/Logic}{logic}, we discuss \blue{equational theorem proving} in
      the last chapter of the first part of this lecture. 
\item In the second part of this lecture, we discuss \blue{machine learning}.  In the last ten years, a number of
      advances in machine learning have made it into the headlines of the news.  The latest hype is caused by
      \href{https://openai.com/blog/chatgpt/}{ChatGPT}.
      When asked to describe itself in 100 words, ChatGPT gave the following answer:
      \begin{center}
        \colorbox{blue}{\framebox{\colorbox{sepia}{
          \begin{minipage}{15cm}
        \textsl{ChatGPT is a large language model created by OpenAI. It uses cutting-edge machine learning
        techniques such as deep learning and neural networks to generate human-like text. It can answer
        questions, write essays, and carry out a wide variety of natural language tasks. ChatGPT is fine-tuned
        on a massive dataset and can generate responses to a wide range of topics. It's designed to be a
        powerful tool for automated content generation, customer service, and other applications where
        understanding and generating human language is critical. With a powerful language model like ChatGPT,
        it's now possible to automate many tasks that once required human intelligence.} 
      \end{minipage}}}}
      \end{center}
      In order to temper the hype about ChatGPT a bit, I would like to share the following conversation that I
      recently had with ChatGPT.
      \begin{description}
       \item[Q:] I have as many brothers as I have sisters.  My sister has twice as many brothers as she has
                 sisters.  How many children does my father have?  
       \item[A:] It is not possible to determine the number of children your father has based on the
                 information provided. Additional information is needed.        
       \item[Q:] What information do you need to proceed?
       \item[A:] I would need to know the number of brothers and sisters you have in order to determine the
                 number of children your father has.  
       \item[Q:] You can find these numbers if you convert the information I have given into two equations,
                 where $b$ is the number of boys and $g$ is the number of girls.  You can then solve this
                 system of equations.    
       \item[A:] Sure, using the information you've provided, we can set up the following system of equations:
                \begin{enumerate}[(a)]
                \item $b + g = bs$ (the number of brothers is equal to the number of sisters)
                \item $b = 2gs$ (your sister has twice as many brothers as she has sisters)

                      To find the number of children your father has, we can substitute the second equation into
                      the first equation: 
                \item $b + g = bs$
                \item $2gs + g = gs$
                \item $2gs + g = g (b + g)$
                \item $2gs + g = g^2$
                \end{enumerate}
                then we can solve for g and find the total number of children.
      \end{description}
      As you can see for yourself, ChatGPT doesn't get any closer to solving this problem.
      
      It is fair to say that currently, machine learning is the hottest topic in computer science.
      Among others, we discuss the following algorithms:
      \begin{enumerate}
      \item \blue{Linear regression} is one of the most fundamental machine learning algorithms.
            In machine learning, we are given a number of data pairs of the form  $\langle \mathbf{x}_i, y_i \rangle$ 
            where $i \in \{1,\cdots,N\}$ and for all $i \in \{1,\cdots,N\}$ we have $\mathbf{x}_i \in \mathbb{R}^m$
            and $y_i \in \mathbb{R}$.  We assume that there is an unknown function $f:\mathbb{R}^m \rightarrow \mathbb{R}$
            such that $y_i \approx f(\mathbf{x}_i)$.  Our task is to find an approximation for the function
            $f$.  When using linear regression, we assume that the function $f$ is linear in its arguments.
            Although this sounds like a strong assumption, we will see that linear regression is surprisingly
            powerful in practice.
      \item In a \blue{classification problem} we again have $N$ pairs of the form $\langle \mathbf{x}_i, y_i
        \rangle$.
            As before,  we have $\mathbf{x}_i \in \mathbb{R}^m$, but now $y_i \in \mathbb{B}$, where
            $\mathbb{B}$ is the set of Boolean values, i.e.~we have $\mathbb{B} = \{\mathtt{true}, \mathtt{false}\}$.
            The task is then to find a function $f:\mathbb{R}^m \rightarrow \mathbb{B}$
            such that the equation $y_i = f(\mathbf{x}_i)$ is true for most $i\in\{1,\cdots,N\}$.  A typical
            classification problem is \href{https://en.wikipedia.org/wiki/Email_spam}{spam detection}.  The
            first algorithm we introduce to solve classification problems is \blue{logistic regression}.
            After that, we study \blue{support vector machines} and \blue{naive Bayes classifiers}.
      \item Finally, we discuss neural networks.  As an example, we will build a neural network that is able to
            recognize digits. 
      \end{enumerate}
\end{enumerate}

\section{Literature}
The main sources of these lecture notes are the following:
\begin{enumerate}
\item A course on artificial intelligence that was offered on the \textsc{edX} platform.  The course
      materials are available at  
      \\[0.2cm]
      \hspace*{1.3cm}
      \href{http://ai.berkeley.edu/home.html}{http://ai.berkeley.edu/home.html}.
\item The book
      \\[0.2cm]
      \hspace*{1.3cm}
      \href{https://www.amazon.de/Artificial-Intelligence-Modern-Approach-Global/dp/1292401133/}{Introduction to Artificial Intelligence}
      \\[0.2cm]
      written by Stuart Russell and Peter Norvig \cite{russell:2020}.
\item A course on artificial intelligence that is offered on \href{https://www.udacity.com}{Udacity}.  The title of the
      course is
      \\[0.2cm]
      \hspace*{1.3cm}
      \href{https://www.udacity.com/course/intro-to-artificial-intelligence--cs271}{Intro to Artificial Intelligence}
      \\[0.2cm]
      and the course is given by \href{https://en.wikipedia.org/wiki/Peter_Norvig}{Peter Norvig}, who is
      director of research at Google and \href{https://en.wikipedia.org/wiki/Sebastian_Thrun}{Sebastian Thrun},
      who is the chairman of \href{https://www.udacity.com}{Udacity}.
\end{enumerate}
When it comes to the exam, you should be fine if you have mastered the material that is covered in my
lecture notes.  Hence, there is no need to buy any book or take any other course.

\remark
The programs presented in these lecture notes are expected to run with the \textsl{Python} version 3.10.
The file 
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Artificial-Intelligence/blob/master/Python/ai.sh}{https://github.com/karlstroetmann/Artificial-Intelligence/blob/master/Python/ai.sh}
\\[0.2cm]
contains a list of commands that can be used to create the \textsl{Python} environment that I have used to test
the notebooks presented in my lectures.  

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "artificial-intelligence"
%%% End:
