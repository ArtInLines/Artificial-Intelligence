\chapter{Introduction}

\section{What is Artificial Intelligence?}
\section{Understanding Artificial Intelligence}
As we embark on exploring \href{https://en.wikipedia.org/wiki/Artificial_intelligence}{Artificial Intelligence}
(AI), it is crucial to define what the term ``\blue{artificial intelligence}'' encompasses. The Oxford
Dictionary of English offers this definition \index{artificial intelligence, definition} of \blue{artificial
  intelligence}: 
\begin{quote}
\colorbox{sepia}{\textsl{The theory and development of computer systems capable of performing tasks that}} \linebreak
\colorbox{sepia}{\textsl{typically require human intelligence, including visual perception, speech recognition,}} \linebreak
\colorbox{sepia}{\textsl{decision-making, and language translation.}}
\end{quote}
Artificial Intelligence has evolved through two primary approaches. The first, known as \blue{symbolic AI}, focuses on \blue{symbolic logic}. \index{symbolic AI} This approach led to the creation of automatic theorem provers, \blue{symbolic integration} systems, and chess-playing programs like \href{https://en.wikipedia.org/wiki/Deep_Blue_(chess_computer)}{Deep Blue}. Initially, symbolic AI was the predominant paradigm in the field.

The second approach, \blue{machine learning}, was defined by Arthur Samuel as ``the field of study that enables
computers to learn without explicit programming'' \cite{samuel:1959}. \index{machine learning, definition} This
approach has primarily fueled the recent hype in AI. 

\section{Overview}
This lecture consists of two parts.
\begin{enumerate}
\item The first part deals with symbolic AI.
      The common theme of symbolic AI is \blue{declarative programming}.  
      The main idea of declarative programming is that we start with a \blue{formal problem specification}.
      This problem specification is a concise description of the problem that is to be solved, which is
      then fed into a \blue{problem solver} that returns a solution of the problem.  Originally, 
      \href{https://en.wikipedia.org/wiki/Declarative_programming}{declarative programming} was a very general
      approach to problem-solving.  The idea was that in order to solve a problem, the problem would first be
      formulated as a logic formula and then some kind of
      \href{https://en.wikipedia.org/wiki/Automated_theorem_proving}{automated theorem prover} would be
      able to solve the problem.  The programming language \href{https://en.wikipedia.org/wiki/Prolog}{Prolog}
      was based on that paradigm.  Unfortunately, the idea of declarative programming has
      turned out to be unsuitable as a general problem-solving framework for two reasons:
      \begin{enumerate}
      \item First, it is very difficult to specify practical problems completely in a logical framework.
      \item Second, even in those cases where it is feasible to completely specify a problem via logic firmulas,
            automatic theorem proving is, in general, not powerful enough to automatically find a solution. 
      \end{enumerate}
      However, there are a number of domains where the approach of declarative programming has turned out to be
      useful.  In particular, we show how declarative programming can be used to solve problems in the
      following domains.
      \begin{enumerate}
      \item \blue{Search problems} are problems where the task is to find a path in a graph.  A typical example of a
            search problem is the \href{https://en.wikipedia.org/wiki/15_puzzle}{fifteen puzzle}.
            We discuss various state-of-the-art algorithms that can solve search problems.
      \item \href{https://en.wikipedia.org/wiki/Constraint_satisfaction_problem}{Constraint satisfaction problems} 
            have great practical importance.  Today, very efficient constraint solvers have been developed to
            solve various constraint satisfaction problems that occur in practise.

            We will first discuss various techniques for solving constraint satisfaction problems.
            Furthermore, we discuss \href{https://github.com/Z3Prover/z3}{Z3}, which is a state-of-the-art
            automatic theorem prover and constraint solver developed by
            \href{https://www.microsoft.com/en-us/research/project/z3-3/}{Microsoft}.
      \item \blue{Games} like \href{https://en.wikipedia.org/wiki/Chess}{chess} or
            \href{https://en.wikipedia.org/wiki/checkers}{checkers} can be specified declaratively and there are
            various techniques for computers to find optimal strategies for playing adversarial games.
      \end{enumerate}
      Additionally we will cover \blue{automatic theorem proving}.  As we have already discussed 
      \blue{resolution theorem proving} in our lecture on
      \href{https://github.com/karlstroetmann/Logic}{logic}, we discuss \blue{equational theorem proving} in
      the last chapter of the first part of this lecture. 
\item In the second part of this lecture, we discuss \blue{machine learning}.  In the last ten years, a number of
      advances in machine learning have made it into the headlines of the news.  The latest hype is caused by
      \href{https://openai.com/blog/chatgpt/}{ChatGPT}.
      When asked to describe itself in 100 words, ChatGPT gave the following answer:
      \begin{center}
        \colorbox{blue}{\framebox{\colorbox{sepia}{
          \begin{minipage}{15cm}
        \textsl{ChatGPT is a large language model created by OpenAI. It uses cutting-edge machine learning
        techniques such as deep learning and neural networks to generate human-like text. It can answer
        questions, write essays, and carry out a wide variety of natural language tasks. ChatGPT is fine-tuned
        on a massive dataset and can generate responses to a wide range of topics. It's designed to be a
        powerful tool for automated content generation, customer service, and other applications where
        understanding and generating human language is critical. With a powerful language model like ChatGPT,
        it's now possible to automate many tasks that once required human intelligence.} 
      \end{minipage}}}}
      \end{center}
      I started to use Chat\textsc{Gpt} at the beginning of 2023.  My early experiments with the version 3.5
      were rather unsatisfactory.  However, in the summer of 2023 I switched to the paid subscription of
      Chat\textsc{Gpt} and started to use the version 4.0.  As a result, my perception of Chat\textsc{Gpt}
      changed fundamentally.  I am now using this new version on a daily basis both for coding purposes and to
      improve my lecture notes.  However, I have recently run into availabilty problems.  At the moment,
      Chat\textsc{Gpt} 4.0 is veeeery slow and only allows at most 40 questions every 3 hours.
      In times of high demands, Open\textsc{Ai} seems to reduce the number of 40 questions every 3 hours
      arbitrarily. 
      
      Nevertheless, I recommend the professional version of Chat\textsc{Gpt} to every student for the 
      following reason:  Five years from now the use of language model will be as common place as the use of a
      search engine like Google is today.  If you want to survive in the future world, you should understand
      the capabilities of large language models and have some experience in using them.  
      
      It is fair to say that currently, machine learning is the hottest topic in computer science.
      Among others, we discuss the following algorithms:
      \begin{enumerate}
      \item \blue{Linear regression} is one of the most fundamental machine learning algorithms.
            In machine learning, we are given a number of data pairs of the form  $\langle \mathbf{x}_i, y_i \rangle$ 
            where $i \in \{1,\cdots,N\}$ and for all $i \in \{1,\cdots,N\}$ we have $\mathbf{x}_i \in \mathbb{R}^m$
            and $y_i \in \mathbb{R}$.  We assume that there is an unknown function $f:\mathbb{R}^m \rightarrow \mathbb{R}$
            such that $y_i \approx f(\mathbf{x}_i)$.  Our task is to find an approximation for the function
            $f$.  When using linear regression, we assume that the function $f$ is linear in its arguments.
            Although this sounds like a strong assumption, we will see that linear regression is surprisingly
            powerful in practice.
      \item In a \blue{classification problem} we again have $N$ pairs of the form $\langle \mathbf{x}_i, y_i
        \rangle$.
            As before,  we have $\mathbf{x}_i \in \mathbb{R}^m$, but now $y_i \in \mathbb{B}$, where
            $\mathbb{B}$ is the set of Boolean values, i.e.~we have $\mathbb{B} = \{\mathtt{true}, \mathtt{false}\}$.
            The task is then to find a function $f:\mathbb{R}^m \rightarrow \mathbb{B}$
            such that the equation $y_i = f(\mathbf{x}_i)$ is true for most $i\in\{1,\cdots,N\}$.  A typical
            classification problem is \href{https://en.wikipedia.org/wiki/Email_spam}{spam detection}.  The
            first algorithm we introduce to solve classification problems is \blue{logistic regression}.
            After that, we study \blue{support vector machines} and \blue{naive Bayes classifiers}.
      \item Finally, we discuss neural networks.  As an example, we will build a neural network that is able to
            recognize digits. 
      \end{enumerate}
\end{enumerate}

\section{Literature}
The main sources of these lecture notes are the following:
\begin{enumerate}
\item A course on artificial intelligence that was offered on the \textsc{edX} platform.  The course
      materials are available at \href{http://ai.berkeley.edu/home.html}{http://ai.berkeley.edu/home.html}.
\item The book \href{https://www.amazon.de/Artificial-Intelligence-Modern-Approach-Global/dp/1292401133/}{
       Introduction to Artificial Intelligence}
      written by Stuart Russell and Peter Norvig \cite{russell:2020}.
\item The course \href{https://www.udacity.com/course/intro-to-artificial-intelligence--cs271}{
      Intro to Artificial Intelligence} course on artificial intelligence that is offered on the
      platform \href{https://www.udacity.com}{Udacity}.  
\end{enumerate}
When it comes to the exam, you should be fine if you have mastered the material that is covered in my
lecture notes.  Hence, there is no need to buy any book or take any other course.
\pagebreak

\remark
The programs presented in these lecture notes are expected to run with the \textsl{Python} version 3.12.
I am using Python 3.12 because of the recent changes to Python's type system.
I have created the Python environment that I am using for these lecture notes via the bash commands shown in
Figure \ref{fig:ai.sh} on page \pageref{fig:ai.sh}.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = bg,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{bash}
    conda create -y -n ai python=3.12 
    conda activate ai
    conda install -c anaconda -y graphviz ply seaborn scikit-learn 
    conda install -c conda-forge -y jupyter python-graphviz matplotlib 
    conda install -c conda-forge -y jupyter memory_profiler autograd 
    pip install ipycanvas
    pip install chess 
    pip install z3-solver  
\end{minted}
\vspace*{-0.3cm}
\caption{Bash command to set up an Anaconda environment for Python.}
\label{fig:ai.sh}
\end{figure}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "artificial-intelligence"
%%% End:
